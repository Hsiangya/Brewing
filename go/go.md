# 数据结构

## 空结构体

`unsafe.Sizeof()`会打印int类型的长度

- int：大小跟随系统字长
- 指针的大小也是系统字长

![image-20240527102306577](./assets/image-20240527102306577.png)

- 空结构体的地址均相同（不被包含在其他结构体中时）

- 空结构体主要为了节约内存

  ```go
  // 实现一个集合
  m:=map[string]struct{}{}
  m["xx"]=struct{}{}
  
  // 管道新建,如果只想给chan发送信号 不需要值
  make(chan struct{})
  ```

## 字符串

![image-20240521223839972](./assets/image-20240521223839972.png)

- 所有字符均使用Unicode字符集

- 使用UTF-8编码

  > - 统一字符集
  > - 囊括159种文字的144679个字符
  > - 14完个字符至少需要3和字节表示
  > - 英文字符均排在前128个

- Unicode的一种变长格式

- 128个US-ASCII字符只需要一个字节编码

- 西方常用字符需要两个字节编码

- 其他字符需要三个字节，极少需要4个字节

![image-20240521224055652](./assets/image-20240521224055652.png)

**字符串的遍历**

![image-20240521225403675](./assets/image-20240521225403675.png)

## 切片

### 描述

字符串与切片都是对底层数组的引用

![image-20240521231100197](./assets/image-20240521231100197.png)

### 切片的创建

![image-20240522215357560](./assets/image-20240522215357560.png)

### 切片的访问

- 下标直接访问元素
- range遍历元素
- len(slice)查看切片长度
- cap(slice)查看数组容量

### 切片扩容

![image-20240522220648663](./assets/image-20240522220648663.png)

在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：

- 如果期望容量大于当前容量的两倍就会使用期望容量
- 如果当前切片的长度小于256就会将容量返回
- 如果当前切片的长度大于256就会每次增加25%的容量，知道新容量大于期望容量

**注意**：

- 切片扩容时，**并发不安全**，注意切片并发要加锁

> 当一个线程读切片，一个线程追加扩容时，会出现读线程读取原来的数组，追加会产生新的数组，因此不安全

![image-20240522222225273](./assets/image-20240522222225273.png)

## 映射Map

映射底层使用HashMap

### 开放寻址法

![image-20240522222742034](./assets/image-20240522222742034.png)

### 拉链法

![image-20240522223145356](./assets/image-20240522223145356.png)

### go中的HashMap

![image-20240523225023502](./assets/image-20240523225023502.png)

### map初始化

**通过make初始化**：

![image-20240527105214742](./assets/image-20240527105214742.png)

**通过字面量初始化**：

![image-20240527111616172](./assets/image-20240527111616172.png)

### map的读写

**读取**：

![image-20240527111701099](./assets/image-20240527111701099.png)

**写入**：

![image-20240527112048119](./assets/image-20240527112048119.png)

### map的扩容

![image-20240527114412272](./assets/image-20240527114412272.png)

- map溢出桶太多时会导致严重的性能下降
- runtime.mapassign()可能会触发扩容情况：
  - 装在因子超过6.5（平均每个槽6.5个key）
  - 使用了太多的溢出桶（溢出桶超过了普通桶）

**扩容类型**

- 等量扩容：数据补多但是溢出桶太多了（整理）
- 翻倍扩容：数据太多了

**扩容步骤**：

- 创建新得桶
  1. 创建一组新桶
  2. oldbuckets指向原有的桶数组
  3. buckets指向新的桶数组
  4. map标记为扩容状态
- 数据迁移
  1. 将所有数据从旧桶驱逐到新桶
  2. 采用渐进式驱逐
  3. 每次操作一个旧桶时，将旧桶数据驱逐到新桶
  4. 读取时不进行驱逐，只判断读取新桶还是旧桶
- 旧buckets回收
  1. 所有的旧桶驱逐完成后
  2. oldbuckets回收

![image-20240527153453445](./assets/image-20240527153453445.png)

### map的并发

- map的读写有并发问题
- A协程在桶中读数据时，B线程驱逐了这个桶(写操作)
- A协程会读到错误的数据或者找不到数据

![image-20240527154552172](./assets/image-20240527154552172.png)

**sync.Map**:

![image-20240527155856254](./assets/image-20240527155856254.png)

**读写**：

![image-20240527162701687](./assets/image-20240527162701687.png)

### 总结

分离了扩容问题、而不是分里了写问题

- map在扩容时会有并发问题
- sync.Map 使用了两个map(read dirty)，分离了扩容问题
- 不会引发扩容的操作（查、改）使用read map
- 可能引发扩容的操作（新增）使用dirty map

> 读多追加少，使用sync.map可以大大提升效率
>
> 如果读少，追加多，和原生map加锁性能并没有提升多少

## 接口

- 只要实现了接口的全部方法，就是自动实现接口
- 可以在不修改代码的情况下抽象出新的接口

## 内存对齐

- 非内存对齐：内存的原子性与效率收到影响
- 内存对齐：提高内存操作效率，有利于原子性

![image-20240527172139096](./assets/image-20240527172139096.png)

### 基本类型对齐

**对齐系数：**

- 为了方便内存对齐，Go提供了对齐系数：`unsafe.Alignof()`
- 含义：变量的内存地址必须被对齐系数整除
- 如果对齐系数为4，表示变量内存地址必须时4的倍数

| 数据类型 | 对齐系数 |
| -------- | -------- |
| bool     | 1        |
| byte     | 1        |
| int8     | 1        |
| int16    | 2        |
| int32    | 4        |
| int64    | 8        |

> 基础类型长度大小和对齐系数一样

![image-20240527173008845](./assets/image-20240527173008845.png)

### 结构体对齐

- 结构体对齐分为内部对齐和结构体之间对齐
- 内部对齐：考虑成员大小和成员的对齐系数
- 结构体长度填充：考虑自身对齐系数和系统字长

**结构体内部对齐：**

- 指的时结构体内部成员的相对位置（偏移量）
- 每个成员的偏移量是自身大小与其对齐系数较小值的倍数

![image-20240527174812265](./assets/image-20240527174812265.png)

**结构体长度填充：**

- 指的是结构体通过增加长度，对其系统字长
- 结构体长度是最大成员长度与系统字长较小的整数倍

![image-20240527180044701](./assets/image-20240527180044701.png)

## 数据结构总结

数据结构长度：

- go中部分数据的长度与系统字长有关
- 空结构体不占用空间（独立时地址是zerobase）
- 空结构体与map结合实现hashset
- 空结构体与channel结合可以当作纯信号

内存对齐

- 提高内存效率，变量之间需要内存对齐
- 基本类型考虑对齐系数
- 结构体既需要内部对其，有需要外部填充对齐
- 空结构体作为最后一个成员，需要填充对齐

字符串与切片：

- 字符串和切片都是对底层数组的引用
- 字符串有UTF-8边长编码的特点
- 切片的容量和长度不同
- 切片追加时可能需要重建底层数组（并发不安全）

map：

- go语言使用拉链实现了hashmap
- 每一个桶中存储键哈希的前8位
- 桶超出8个数据，就会存储到溢出桶中
- 装载系数或者溢出桶的增加，会触发map扩容
- "扩容"可能并不是增加桶数，而是挣莉
- map扩容采用渐进式，桶被操作时才会从新被分配

sync.Map:

- map在扩容时会有并发问题
- sync.Map使用了两个map,分里了扩容问题
- 不会引发扩容的操作（查、改）使用read map
- 可能引发扩容的操作（新增）使用dirty map

接口：

- Go的隐式接口更加方便系统的扩产和重构
- 结构体和指针都可以实现接口
- 空结构值可以承载任何类型的数据

nil/空结构体/空接口

- nil是多个类型的零值，或者空值
- 空结构体的指针和值都不是nil
- 空接口零值是nil,一旦有了类型信息就不是nil

# Goroutine

## 进程、线程、协程

进程：

-  操作系统"程序"的最小单位
- 进程用来占用内存空间

线程:

- 每个进程可以有多个线程
- 线程使用系统分配给进程的内存，线程之间共享内存
- 线程用来占用CPU时间
- 线程的调度需要由系统进行，开销比较大
- 线程切换开销大

协程：

- 将一段程序的运行状态打包，可以在线程之间调度
- 协程并不取代线程，协程也要在线程上运行
- 线程是协程的资源，协程使用线程这个资源

## Goroutine结构

![image-20240528091249874](./assets/image-20240528091249874.png)

- runtime中，协程本质是一个g结构体
- stack：堆栈地址
- gobuf：目前程序运行现场
- atomicstatus：协程状态

![image-20240528092201169](./assets/image-20240528092201169.png)

## goroutine运行

### 单线程循环

![image-20240528104213991](./assets/image-20240528104213991.png)

- 协程的本质是一个g结构体
- g结构体记录了协程栈、PC信息
- 嘴贱情况下，线程执行标准调度循环，执行协程

### 多线程循环

![image-20240528104509371](./assets/image-20240528104509371.png)

- 操作系统并不知道goroutine的存在
- 操作系统线程执行一个调度循环，顺序执行Goroutine
- 调度循环非常像线程池

## GMP调度模型

### 结构

解决的问题：

- 协程顺序执行，无法并发
- 多线程并发时，会抢夺协程队列的全局锁

![image-20240528110300168](./assets/image-20240528110300168.png)

### gouroutine的获取

**P的作用**

- M与G之间的中介（送料器）
- P持有一些G，使得每次获取G的时候不用从全局找
- 大大减少了并发的执行

![image-20240528115732012](./assets/image-20240528115732012.png)

- 先从本地队列获取goroutine
- 本地没有则上锁，从全局队列获取
- 如果全局队列也没用，去其他的P偷取
- 增加了goroutine的利用路

### goroutine的新建

- 随机寻找一个P
- 将新协程放入P的runnext（插队）
- 若P本地队列满了，放入全局队列

![image-20240528120512499](./assets/image-20240528120512499.png)

解决了问题：

- 多线程并发时，会抢夺协程队列的全局锁

### goroutine的并发

![image-20240528121756083](./assets/image-20240528121756083.png)

### goroutine的切换

#### 主动挂起

![image-20240528122903281](./assets/image-20240528122903281.png)

#### 系统完成调用时

![image-20240528123723701](./assets/image-20240528123723701.png)

#### 总结

- 协程顺序执行，会有饥饿问题
- 协程执行中间，将协程挂起，执行其他协程
- 完成系统调用时挂起，也可以主动挂起
- 方只全局队列饥饿，本地队列随机抽取全局队列

## groutine调度

### 基于写作的抢占式调度

![image-20240528172526264](./assets/image-20240528172526264.png)

### 基于信号的抢占式调度

如果一个goroutine永远不调用morestack()，此时依靠基于信号的抢占式调度

- 操作系统中，有很多基于信号的底层通信方式
- 比如SIGPIPE/SIGURG/SIGHIP
- 线程可以注册对应信号的处理函数

流程：

- 注册SIGURG信号的处理函数（紧急信号）
- GC工作时，向目标线程发送信号
- 线程收到信号，触发调度

![image-20240528173248921](./assets/image-20240528173248921.png)

### 总结

- 基于系统调用和主动挂起，协程可能无法调度
- 基于**协作**的抢占式调度：业务主动调用morestack()
- 基于**信号**的抢占式调度：强制线程调用doSigPreempt()

## 协程太多的问题

**限制goroutine的原因**：

- 文件打开数限制
- 内存限制
- 调度开销过大

**解决方法**：

- 优化业务逻辑

- 利用channel的缓冲区

  ![image-20240528174210490](./assets/image-20240528174210490.png)

  > 适合一大批相同情况下的goroutine

- 协程池

  > 预创建一些协程，使用的时候从池子里拿出一些，使用完后放回
  >
  > go的GMP模型已经类似于池化过了，go的初中时希望goroutine即用即毁

- 调整系统资源

**总结**:

- 太多的goroutine会给程序运行带来性能和稳定性问题
- 牺牲并发特性，利用channel缓冲

## 总结

为什么用协程：

- 协程用来精细利用线程
- 协程可以支撑超高并发

协程是什么：

- 从runtime的角度看，协程就是一个可以被调度的g结构体
- 从线程的角度看，协程就是一段程序，自带执行现场

GMP模型：

- 通过P结构体，达成了缓存部分G的目的
- P本质上就是一个G的本地队列，避免全局并发等待
- 窃取式工作分配机制能够更加充分利用线程资源

协程并发：

- 如果协程顺序执行，会有饥饿问题
- 协程执行中间，将携程挂起，执行其他协程
- 完成系统调用时挂起，也可以主动挂起
- 防止全局队列饥饿，本地队列随机抽取全局队列

抢占式调度：

- 基于系统调用和主动挂起，协程可能无法调度
- 基于写作的抢占式调度：业务主动调用morestack()
- 基于信号的抢占式调度：强制线程调用doSigPreempt()

# Channel

## 数据结构

![image-20240514165116146](./assets/image-20240514165116146.png)

## 创建管道

# 内存管理

## 内存分配器

程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域：栈区(Stack)和堆区(Heap)。

**栈区**：

- 函数调用的参数、返回值以及局部变量大都会被分配到栈上
- 这部分内存会由编译器进行管理
- Go 以及 Java 等编程语言会由工程师和编译器共同管理

**堆区**：

- 堆中的对象由内存分配器分配并由垃圾收集器回收

### 设计原理

![image-20240514171524393](./assets/image-20240514171524393.png)

内存分配器一般包含两种分配方法：

- 线性分配器（Sequential Allocator，Bump Allocator）
- 空闲链表分配器（Free-List Allocator）

### 线性分配器

![image-20240514173026903](./assets/image-20240514173026903.png)

由于线性分配器具有上述特性，所以需要与合适的垃圾回收算法配合使用：

- 标记压缩（Mark-Compact）
- 复制回收（Copying GC）
- 分带回收（Generational GC）
- .........

它们可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能

线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以C与C++等需要直接对外暴露指针的语言就无法使用该策略

### 空闲链表分配器

因为不同的内存块通过指针构成了链表，所以这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以时间复杂度是O(n)，空闲链表分配器可以选择不同的策略再链表中的内存块中进行选择：

- 首次适应（First-Fit）：从链表头开始遍历，选择第一个大小大于申请内存的内存块
- 循环首次适应（Next-Fit）：从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块
- 最优适应（Best-Fit）：从链表头遍历整个链表，选择最合适的内存块
- 隔离适应（Segregated-Fit）：将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块

go语言使用的内存分配策略与第四种策略有些相似：

![image-20240514174704702](./assets/image-20240514174704702.png)

### 分级分配

线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。

**对象大小**

go语言的内存分配器会根据申请分配的内存大小选择不同的逻辑处理，运行时根据对象的大小将对象分成**为对象、小对象和大对象**:

| 类别   | 大小         |
| ------ | ------------ |
| 微对象 | `(0,16B)`    |
| 小对象 | `[16B,32KB]` |
| 大对象 | `(32KB,+∞)`  |

因为程序冲的绝大多数对象的大小都在32KB一下，而申请的内存大小影响Go运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能

### 分级缓存

内存分配不仅会区别对待大小不同的对象，还会将内存分成不同的级别进行管理，TCMalloc和go运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存：

![image-20240514222156144](./assets/image-20240514222156144.png)

### 线性内存

go1.10以前的版本，堆区内存空间都是连续的

![image-20240515114021774](./assets/image-20240515114021774.png)

- 对于任意一个地址，可以根据据arena的基地址计算出所在的页数并通过spans数组获得管理该片区内存的管理单元runtime.mspan
- spans数组中多个连续的位置可能对应同一个runtime.mspan结构

go 语言在垃圾回收机制时会根据指针的地址判断对象是否在堆中，并通过上述方法找到管理对象runtime.mspan。这些都建立在堆区的内存是连续的这一假设上。这种设计虽然简单并且防弊案，但是在C和go混合使用时会导致程序崩溃

1. 分配的内存地址会发生冲突，导致堆的初始化和扩容失败
2. 没有被预留的大块内存可能会被分配给C语言的二进制，导致扩容后的堆不连续

线性的堆内存需要预留大块的内存空间，但是申请大块的内存空间而不适用时不切实际的，不预留内存空间却会在特殊场景下造成程序崩溃。虽然连续内存的实现比较简单，但是这些问题也没有办法忽略。

**内存申请流程**：

1. 内存申请
2. 通过bitmap查找空闲内存
3. 通过arena的基地址获取管理器spans
4. 分配内存，求改bitmap中该内存使用情况

### 稀疏内存

稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂：

![image-20240515140848172](./assets/image-20240515140848172.png)

不同平台和架构的二维数组大小可能完全不同：

- go语言服务在Linux的x86-64架构上运行，二维数组的一维大小会是1，二位大小是4394304

  > 每一个指针占用8字节的内存空间，所以辕信息的总大小是32MB

- 由于每个runtime.heapAreana都会管理64MB的内存，整个堆区最多可以管理256TB的内存，这比之前的512GB多好几个数量级

由于内存的管理变得更加复杂，上述改动对垃圾回收稍有影响，大约会增加 1% 的垃圾回收开销，不过

## 垃圾收集器

### 设计原理

![image-20240515141523513](./assets/image-20240515141523513.png)

##

### 标记清除

标记清楚Mark-Sweep算法是最常见的垃圾收集算法，标记清楚收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清楚（Sweep）两个阶段

1. 标记阶段：从跟对象触发查找并标记堆中所有存活的对象
2. 清除阶段：遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表

![image-20240515143506131](./assets/image-20240515143506131.png)

- 垃圾收集器从垃圾手机的根对象触发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活
- 标记结束后，垃圾收集器会依次遍历堆中的对象并清楚其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中页不能执行
- 我们需要用到更复杂的机制来解决STW的问题

### 三色抽象

为了解决原始标记清楚算法带来的长时间STW，多数现代的追踪是垃圾收集器都会实现三色标记算法的变种以缩短STW的时间，三色标记算法将程序中的对象分成白色、黑色、灰色三类：

- 白色对象：潜在的垃圾，其内存可能会被垃圾收集器回收
- 黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从跟对象可达的对象
- 灰色对象：活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象

![image-20240515145803251](./assets/image-20240515145803251.png)

三色标记垃圾收集器工作原理：

- 从灰色对象的集合中选择一个灰色对象，并将其标记成黑色
- 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收
- 重复上述两个步骤知道对象图中不存在灰色对象

![image-20240515150232574](./assets/image-20240515150232574.png)

 ![image-20240515150458116](./assets/image-20240515150458116.png)

本来不应该回收的对象却被回收了，这在内存管理中是非常严重的错误，将这种错误成为悬挂指针

### 屏障技术

- 多数的现代处理器都会乱序执行指令以最大化性能
- 该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存品璋后执行的操作一定会先于内存屏障后执行的操作 

想要在并发或者增量的标记算法中保证正确性，需要达成一下两种三色不变性（Tri-color invariant）中的一种：

- 强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象
- 弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

![image-20240515155416688](./assets/image-20240515155416688.png)

垃圾收集中的屏障技术更像是一个钩子方法，他是在用户程序读取对象、创建对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以分成读屏障（Read barrier）和写屏障（Write barrier）:

- 读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以变成语言往往都会采用写屏障保证三色不变性

### 插入写屏障

![image-20240515161620591](./assets/image-20240515161620591.png)

### 删除写屏障

删除写屏障一旦开始工作，他会保证开启写屏障时堆上搜友对象的可达，所以也被称作快照垃圾收集（Snapshot GC）

![image-20240519192055935](./assets/image-20240519192055935.png)

### 三色标记法+混合写屏障机制

- 插入写屏障不足：结束时需要STW来重新扫描栈，大约需要10~100ms
- 删除写屏障不足：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉

GoV1.8的三色标记法+混合写屏障机制：

1. GC开始将栈上的对象全部扫描并标记为黑色（之后不在进行第二次重复扫描，无需STW）
2. GC期间，任何在栈上创建的新对象，均为黑色
3. 被删除的对象标记为灰色
4. 被添加的对象标记为灰色

**满足变形的弱三色不变式（结合了插入、删除写屏蔽两者的优点）**

![image-20240519214201428](./assets/image-20240519214201428.png)

### 混合写屏障案例场景

#### 堆对象删除，栈对象引用

![image-20240519215940169](./assets/image-20240519215940169.png)

#### 栈对象删除，栈对象引用

![image-20240519223845452](./assets/image-20240519223845452.png)

#### 堆对象删除，堆对象引用![image-20240519224538682](./assets/image-20240519224538682.png)

#### 栈对象删除，堆对象引用

![image-20240519225424875](./assets/image-20240519225424875.png)

### GC总结

- 强三色不变式：强制性的不允许黑色对象引用白色
- 弱三色不变式：黑色对象可以引用白色对象，但该白色对象必须存在灰色对象引用它
- 三色标记满足强弱不变式之一，即可保证对象不丢失
- 为了满足强三色：插入屏障：添加一个下游引用对象时，标记为灰色
- 为了满足弱三色：删除屏障，当一个对象被删除时，标记为灰色

为了不进行STW，引入了三色标记和混合写屏障

- 栈中能到达的对象都标记为灰色
- 堆中的对象启用插入写屏障和删除写屏障
- 这总情况被删除的对象不被其他对象引用，会在当前的GC周期存活，下一个GC周期被回收
